# 实验二：基于 UDP 的可靠数据传输协议实现（Windows）

> ```
> // 编译
> g++ -std=c++11 receiver.cpp -o receiver.exe -lws2_32
> g++ -std=c++11 sender.cpp -o sender.exe -lws2_32
> // 运行（先接收端，后发送端）
> // 参数：<IP> <端口> <文件> <窗口大小> <丢包率>
> receiver.exe 0.0.0.0 9000 recv.bin 64 0.03
> sender.exe 127.0.0.1 9000 test.bin 64 0.03
> ```



## 一、实验目的

1. 理解 TCP 可靠传输机制的核心思想，包括连接管理、差错控制、流量控制和拥塞控制。
2. 在**用户空间**基于**数据报套接字（UDP）\**设计并实现一个\**面向连接的可靠数据传输协议**。
3. 掌握滑动窗口、选择确认（SACK）及 TCP Reno 拥塞控制算法的基本实现方法。
4. 在 Windows 环境下使用原生 Socket API 进行网络程序设计，并通过实验分析窗口大小和丢包率对传输性能的影响。

------

## 二、实验环境

- 操作系统：Windows 10 / Windows 11
- 编程语言：C++（C++11）
- 编译器：MinGW-w64 g++
- 网络接口：Winsock2（`ws2_32`）
- Socket 类型：UDP（`SOCK_DGRAM`）

------

## 三、协议总体设计

### 3.1 设计思路

UDP 本身不提供可靠性、顺序性和连接管理。本实验在 UDP 之上，自行设计一套轻量级可靠传输协议，功能上模拟 TCP 的关键机制，但仅支持**单向数据传输**（Sender → Receiver），控制信息双向交互。

协议的设计目标包括：

- 提供逻辑上的“连接”语义
- 保证数据可靠、有序、不重复
- 支持流水线发送和选择性重传
- 具备基本的流量控制和拥塞控制能力

------

### 3.2 报文格式设计

所有控制信息和数据均通过 UDP 负载携带自定义协议头，协议头格式如下：

| 字段        | 含义                               |
| ----------- | ---------------------------------- |
| `seq`       | 本数据段起始字节序号               |
| `ack`       | 累计确认号（下一个期望字节）       |
| `flags`     | 标志位（SYN / ACK / FIN / DATA）   |
| `wnd`       | 接收窗口大小（固定，单位：分片数） |
| `len`       | 数据长度                           |
| `checksum`  | 16 位校验和                        |
| `sack_mask` | 选择确认位图（SACK）               |

其中：

- `seq` 和 `ack` 按字节编号，便于处理变长数据
- `sack_mask` 使用 64 位位图，表示在 `ack` 之后的最多 64 个分片的接收情况，支持更大的窗口配置

------

### 3.3 连接管理机制

#### 3.3.1 连接建立（三次握手）

连接建立过程模拟 TCP 的三次握手：

1. Sender → Receiver：`SYN`
2. Receiver → Sender：`SYN + ACK`
3. Sender → Receiver：`ACK`

双方在握手阶段同步初始序号，并建立逻辑连接。

#### 3.3.2 连接关闭（四次挥手）

数据发送完成后，使用 `FIN` 标志进行连接释放，流程与 TCP 类似，保证双方正常结束通信。

------

## 四、可靠传输机制实现

### 4.1 差错检测

采用 16 位反码校验和（Internet Checksum）：

- 发送端对“协议头 + 数据”计算校验和
- 接收端验证校验和，若出错则直接丢弃该分组

------

### 4.2 流水线与选择确认（SACK）

#### 4.2.1 流水线传输

发送端采用滑动窗口方式发送数据：

- 允许多个数据段在网络中同时存在
- 不采用停等协议，提高链路利用率

#### 4.2.2 选择确认（SACK）

接收端在 ACK 中携带 SACK 位图：

- `ack` 表示累计确认
- `sack_mask` 表示已收到的乱序分片

发送端根据 SACK 信息，仅对丢失的数据段进行重传，从而减少不必要的重复发送。

------

### 4.3 流量控制

- 发送窗口大小与接收窗口大小相同，均为**固定大小窗口**
- 窗口大小在程序启动时通过参数指定
- 有效发送窗口为：
	 `min(固定窗口, 拥塞窗口)`

该机制防止发送端发送速率超过接收端处理能力。

------

## 五、拥塞控制算法（TCP Reno）

本实验实现了 TCP Reno 的核心机制：

### 5.1 关键参数

- `cwnd`：拥塞窗口（单位：分片）
- `ssthresh`：慢启动阈值

### 5.2 算法流程

1. **慢启动阶段**
	- 初始 `cwnd = 1`
	- 每收到一个新的 ACK，`cwnd` 增加 1
2. **拥塞避免阶段**
	- 当 `cwnd ≥ ssthresh`
	- 采用加性增大方式，使 `cwnd` 线性增长
3. **快速重传与快速恢复**
	- 连续收到 3 个重复 ACK，立即重传最早未确认的数据段
	- 设置 `ssthresh = cwnd / 2`
	- `cwnd = ssthresh + 3`
4. **超时重传**
	- 若发生超时：
		- `ssthresh = cwnd / 2`
		- `cwnd = 1`
		- 回到慢启动阶段

------

## 六、程序结构与实现说明

### 6.1 程序结构

程序分为三个主要模块：

- `sender.cpp`：发送端，实现连接建立、文件分片、流水线发送、ACK 处理和 Reno 拥塞控制
- `receiver.cpp`：接收端，实现连接管理、乱序缓存、SACK 生成和文件重组
- `rdt.h`：协议头定义、校验和函数及公共工具函数

------

### 6.2 关键数据结构

- 发送端：
	- 发送缓冲区（map<seq, segment>）
	- 拥塞控制状态变量（cwnd、ssthresh）
- 接收端：
	- 乱序接收缓冲区
	- 当前期望序号（累计 ACK）

------

### 6.3 丢包率与延时模拟

为了便于实验分析，在发送端和接收端都引入了可配置的模拟功能：

- **丢包模拟**：双向丢包，DATA 和 ACK 都可能丢失，更真实地模拟网络环境
- **延时模拟**：每次发送时添加 5-10ms 的随机延时，模拟网络传输延时

------

## 七、实验结果与分析

### 7.1 窗口大小对性能的影响

- 窗口较小时，流水线深度不足，链路利用率低
- 随着窗口增大，吞吐率明显提升
- 当窗口大于带宽时延积后，性能提升趋于平缓

### 7.2 丢包率对性能的影响

- 丢包率较低时，Reno 能保持较高吞吐率
- 丢包率升高后，频繁触发重传和拥塞窗口回退，吞吐率明显下降
- 选择确认（SACK）相比仅累计 ACK，能显著减少重传次数

------

## 八、实验总结

本实验在 UDP 之上成功实现了一套具备连接管理、可靠传输、流量控制和 TCP Reno 拥塞控制机制的协议。通过实验过程，加深了对 TCP 内部工作机制的理解，尤其是滑动窗口、选择确认和拥塞控制算法的协同作用。

实验表明，在不依赖操作系统内核 TCP 的情况下，用户空间同样可以实现功能完备的可靠传输协议，但实现复杂度和调试成本显著增加，这也体现了 TCP 协议设计的成熟性与工程价值。